/**
 * Unit tests for the GenerationDependencyGraph class
 */

import { beforeEach, describe, expect, it } from "vitest";
import type { DetailedSchemaChange } from "../../types/core";
import { createDependencyGraph } from "../dependencyGraph";

describe("GenerationDependencyGraph", () => {
  let graph: ReturnType<typeof createDependencyGraph>;

  beforeEach(() => {
    graph = createDependencyGraph();
  });

  describe("dependency management", () => {
    it("should add and retrieve dependencies correctly", () => {
      graph.addDependency("schema.json", "output.ts");
      graph.addDependency("schema.json", "component.tsx");

      const dependents = graph.getDependents("schema.json");
      expect(dependents).toContain("output.ts");
      expect(dependents).toContain("component.tsx");
      expect(dependents).toHaveLength(2);
    });

    it("should handle multiple dependencies for same file", () => {
      graph.addDependency("schema1.json", "shared.ts");
      graph.addDependency("schema2.json", "shared.ts");

      expect(graph.getDependents("schema1.json")).toContain("shared.ts");
      expect(graph.getDependents("schema2.json")).toContain("shared.ts");
    });

    it("should return empty array for unknown file", () => {
      const dependents = graph.getDependents("unknown.json");
      expect(dependents).toEqual([]);
    });
  });

  describe("entity change analysis", () => {
    it("should identify affected files for entity creation", () => {
      const change: DetailedSchemaChange = {
        type: "created",
        path: "entities/users.json",
        schemaType: "entity",
        name: "users",
        currentSchema: {
          tableName: "users",
          displayName: "Users",
          columns: {},
        },
      };

      const affectedFiles = graph.getAffectedFiles([change]);

      const filePaths = affectedFiles.map((f) => f.path);
      expect(filePaths).toContain("src/models/users.ts");
      expect(filePaths).toContain("src/components/users/usersForm.tsx");
      expect(filePaths).toContain("src/components/users/usersTable.tsx");
      expect(filePaths).toContain("src/components/users/usersModal.tsx");
      expect(filePaths).toContain("src/app/api/users/route.ts");
      expect(filePaths).toContain("src/app/users/page.tsx");
    });

    it("should identify affected files for entity updates", () => {
      const change: DetailedSchemaChange = {
        type: "updated",
        path: "entities/users.json",
        schemaType: "entity",
        name: "users",
        previousSchema: { tableName: "users", columns: {} },
        currentSchema: { tableName: "users", columns: { name: {} } },
        fieldChanges: [
          {
            field: "columns",
            type: "modified",
            oldValue: {},
            newValue: { name: {} },
          },
        ],
      };

      const affectedFiles = graph.getAffectedFiles([change]);

      expect(affectedFiles.length).toBeGreaterThan(0);
      expect(affectedFiles.some((f) => f.path === "src/models/users.ts")).toBe(
        true
      );
      expect(affectedFiles.some((f) => f.path.includes("migrations"))).toBe(
        true
      );
    });

    it("should generate migration files for database schema changes", () => {
      const change: DetailedSchemaChange = {
        type: "updated",
        path: "entities/users.json",
        schemaType: "entity",
        name: "users",
        fieldChanges: [
          {
            field: "columns",
            type: "modified",
            oldValue: {},
            newValue: { newColumn: {} },
          },
        ],
      };

      const affectedFiles = graph.getAffectedFiles([change]);

      const migrationFile = affectedFiles.find((f) =>
        f.path.includes("migrations")
      );
      expect(migrationFile).toBeDefined();
      expect(migrationFile?.generator).toBe("models");
      expect(migrationFile?.reason[0]).toContain("Database schema change");
    });

    it("should still generate UI files by default for most changes", () => {
      const change: DetailedSchemaChange = {
        type: "updated",
        path: "entities/users.json",
        schemaType: "entity",
        name: "users",
        fieldChanges: [
          {
            field: "tableName",
            type: "modified",
            oldValue: "users",
            newValue: "user_accounts",
          },
        ],
      };

      const affectedFiles = graph.getAffectedFiles([change]);

      // Should generate models
      expect(affectedFiles.some((f) => f.path === "src/models/users.ts")).toBe(
        true
      );
      // UI files should be generated by default logic (conservative approach)
      expect(affectedFiles.some((f) => f.path.includes("components"))).toBe(
        true
      );
    });
  });

  describe("enum change analysis", () => {
    it("should identify affected files for enum creation", () => {
      const change: DetailedSchemaChange = {
        type: "created",
        path: "enums/status.json",
        schemaType: "enum",
        name: "status",
        currentSchema: {
          values: {
            ACTIVE: { label: "Active" },
            INACTIVE: { label: "Inactive" },
          },
        },
      };

      const affectedFiles = graph.getAffectedFiles([change]);

      const filePaths = affectedFiles.map((f) => f.path);
      expect(filePaths).toContain("src/models/enums/status.ts");
      expect(filePaths).toContain("src/models/index.ts");
    });

    it("should identify affected files for enum updates", () => {
      const change: DetailedSchemaChange = {
        type: "updated",
        path: "enums/status.json",
        schemaType: "enum",
        name: "status",
        fieldChanges: [
          {
            field: "values",
            type: "modified",
            oldValue: { ACTIVE: { label: "Active" } },
            newValue: {
              ACTIVE: { label: "Active" },
              PENDING: { label: "Pending" },
            },
          },
        ],
      };

      const affectedFiles = graph.getAffectedFiles([change]);

      expect(affectedFiles.length).toBeGreaterThan(0);
      expect(affectedFiles.some((f) => f.generator === "models")).toBe(true);
    });
  });

  describe("page change analysis", () => {
    it("should identify affected files for page creation", () => {
      const change: DetailedSchemaChange = {
        type: "created",
        path: "pages/dashboard.json",
        schemaType: "page",
        name: "dashboard",
        currentSchema: {
          route: "/dashboard",
          title: "Dashboard",
          sections: [],
        },
      };

      const affectedFiles = graph.getAffectedFiles([change]);

      expect(affectedFiles).toHaveLength(1);
      expect(affectedFiles[0].path).toBe("src/app/dashboard/page.tsx");
      expect(affectedFiles[0].generator).toBe("pages");
    });

    it("should identify affected files for page updates", () => {
      const change: DetailedSchemaChange = {
        type: "updated",
        path: "pages/dashboard.json",
        schemaType: "page",
        name: "dashboard",
        fieldChanges: [
          {
            field: "title",
            type: "modified",
            oldValue: "Dashboard",
            newValue: "Admin Dashboard",
          },
        ],
      };

      const affectedFiles = graph.getAffectedFiles([change]);

      expect(affectedFiles[0].path).toBe("src/app/dashboard/page.tsx");
    });
  });

  describe("app config change analysis", () => {
    it("should identify affected files for app config changes", () => {
      const change: DetailedSchemaChange = {
        type: "updated",
        path: "app.json",
        schemaType: "app",
        name: "app",
        fieldChanges: [
          {
            field: "name",
            type: "modified",
            oldValue: "Old App",
            newValue: "New App",
          },
        ],
      };

      const affectedFiles = graph.getAffectedFiles([change]);

      const filePaths = affectedFiles.map((f) => f.path);
      expect(filePaths).toContain("src/app/layout.tsx");
    });

    it("should generate navigation files for navigation changes", () => {
      const change: DetailedSchemaChange = {
        type: "updated",
        path: "app.json",
        schemaType: "app",
        name: "app",
        fieldChanges: [
          {
            field: "navigation",
            type: "modified",
            oldValue: {},
            newValue: { header: [] },
          },
        ],
      };

      const affectedFiles = graph.getAffectedFiles([change]);

      expect(
        affectedFiles.some((f) => f.path === "src/components/Navigation.tsx")
      ).toBe(true);
    });

    it("should generate auth files for auth changes", () => {
      const change: DetailedSchemaChange = {
        type: "updated",
        path: "app.json",
        schemaType: "app",
        name: "app",
        fieldChanges: [
          {
            field: "auth",
            type: "modified",
            oldValue: {},
            newValue: { provider: "nextauth" },
          },
        ],
      };

      const affectedFiles = graph.getAffectedFiles([change]);

      expect(
        affectedFiles.some((f) =>
          f.path.includes("api/auth/[...nextauth]/route.ts")
        )
      ).toBe(true);
    });
  });

  describe("multiple changes", () => {
    it("should merge reasons for multiple changes affecting same file", () => {
      const changes: DetailedSchemaChange[] = [
        {
          type: "updated",
          path: "entities/users.json",
          schemaType: "entity",
          name: "users",
          fieldChanges: [{ field: "columns", type: "modified" }],
        },
        {
          type: "updated",
          path: "entities/users.json",
          schemaType: "entity",
          name: "users",
          fieldChanges: [{ field: "displayName", type: "modified" }],
        },
      ];

      const affectedFiles = graph.getAffectedFiles(changes);

      const modelFile = affectedFiles.find(
        (f) => f.path === "src/models/users.ts"
      );
      expect(modelFile?.reason.length).toBeGreaterThan(1);
    });

    it("should handle changes across different schema types", () => {
      const changes: DetailedSchemaChange[] = [
        {
          type: "created",
          path: "entities/users.json",
          schemaType: "entity",
          name: "users",
        },
        {
          type: "updated",
          path: "enums/status.json",
          schemaType: "enum",
          name: "status",
        },
        {
          type: "created",
          path: "pages/dashboard.json",
          schemaType: "page",
          name: "dashboard",
        },
      ];

      const affectedFiles = graph.getAffectedFiles(changes);

      const generators = new Set(affectedFiles.map((f) => f.generator));
      expect(generators).toContain("models");
      expect(generators).toContain("components");
      expect(generators).toContain("api");
      expect(generators).toContain("pages");
    });
  });

  describe("utility methods", () => {
    it("should clear all dependencies", () => {
      graph.addDependency("file1", "file2");
      graph.addDependency("file3", "file4");

      const statsBefore = graph.getStats();
      expect(statsBefore.totalFiles).toBeGreaterThan(0);

      graph.clear();

      const statsAfter = graph.getStats();
      expect(statsAfter.totalFiles).toBe(0);
      expect(statsAfter.totalDependencies).toBe(0);
    });

    it("should provide accurate statistics", () => {
      graph.addDependency("schema1", "output1");
      graph.addDependency("schema1", "output2");
      graph.addDependency("schema2", "output3");

      const stats = graph.getStats();
      expect(stats.totalFiles).toBe(2);
      expect(stats.totalDependencies).toBe(3);
    });
  });
});
